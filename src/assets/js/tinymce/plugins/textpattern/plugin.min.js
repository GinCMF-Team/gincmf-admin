/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.4.1 (2020-07-08)
 */
!(function (f) {
  
  const t = tinymce.util.Tools.resolve("tinymce.PluginManager");
    var u = function () {
      return (u =
        Object.assign ||
        function (t) {
          for (var n, r = 1, e = arguments.length; r < e; r++)
            for (const o in (n = arguments[r]))
              Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
          return t;
        }).apply(this, arguments);
    };
  let n;
    let r;
    let e;
    const o = function () {};
    const a = function (t) {
      return function () {
        return t;
      };
    };
    const i = function (t) {
      return t;
    };
    const c = a(!1);
    const s = a(!0);
    const l = function () {
      return d;
    };
    var d =
      ((n = function (t) {
        return t.isNone();
      }),
      {
        fold (t, n) {
          return t();
        },
        is: c,
        isSome: c,
        isNone: s,
        getOr: (e = function (t) {
          return t;
        }),
        getOrThunk: (r = function (t) {
          return t();
        }),
        getOrDie (t) {
          throw new Error(t || "error: getOrDie called on none.");
        },
        getOrNull: a(null),
        getOrUndefined: a(undefined),
        or: e,
        orThunk: r,
        map: l,
        each: o,
        bind: l,
        exists: c,
        forall: s,
        filter: l,
        equals: n,
        equals_: n,
        toArray () {
          return [];
        },
        toString: a("none()"),
      });
    var m = function (r) {
      const t = a(r);
        const n = function () {
          return o;
        };
        const e = function (t) {
          return t(r);
        };
        var o = {
          fold (t, n) {
            return n(r);
          },
          is (t) {
            return r === t;
          },
          isSome: s,
          isNone: c,
          getOr: t,
          getOrThunk: t,
          getOrDie: t,
          getOrNull: t,
          getOrUndefined: t,
          or: n,
          orThunk: n,
          map (t) {
            return m(t(r));
          },
          each (t) {
            t(r);
          },
          bind: e,
          exists: e,
          forall: e,
          filter (t) {
            return t(r) ? o : d;
          },
          toArray () {
            return [r];
          },
          toString () {
            return `some(${  r  })`;
          },
          equals (t) {
            return t.is(r);
          },
          equals_ (t, n) {
            return t.fold(c, function (t) {
              return n(r, t);
            });
          },
        };
      return o;
    };
    const y = {
      some: m,
      none: l,
      from (t) {
        return t === null || t === undefined ? d : m(t);
      },
    };
    const g = function (e) {
      return function (t) {
        return (
          (r = typeof (n = t)),
          (n === null
            ? "null"
            : r == "object" &&
              (Array.prototype.isPrototypeOf(n) ||
                (n.constructor && n.constructor.name === "Array"))
            ? "array"
            : r == "object" &&
              (String.prototype.isPrototypeOf(n) ||
                (n.constructor && n.constructor.name === "String"))
            ? "string"
            : r) === e
        );
        let n; let r;
      };
    };
    const p = g("string");
    const h = g("object");
    const v = g("array");
    const b = Array.prototype.slice;
    const k = Array.prototype.indexOf;
    const O = function (t, n) {
      return (r = t), (e = n), k.call(r, e) > -1;
      let r; let e;
    };
    const w = function (t, n) {
      for (var r = t.length, e = new Array(r), o = 0; o < r; o++) {
        const a = t[o];
        e[o] = n(a, o);
      }
      return e;
    };
    const C = function (t, n) {
      for (let r = 0, e = t.length; r < e; r++) {
        n(t[r], r);
      }
    };
    const E = function (t, n) {
      for (var r = [], e = 0, o = t.length; e < o; e++) {
        const a = t[e];
        n(a, e) && r.push(a);
      }
      return r;
    };
    const x = function (t, n, r) {
      return (
        (function (t, n) {
          for (let r = t.length - 1; r >= 0; r--) {
            n(t[r], r);
          }
        })(t, function (t) {
          r = n(r, t);
        }),
        r
      );
    };
    const R = function (t, n) {
      return (function (t, n, r) {
        for (let e = 0, o = t.length; e < o; e++) {
          const a = t[e];
          if (n(a, e)) return y.some(a);
          if (r(a, e)) break;
        }
        return y.none();
      })(t, n, c);
    };
    const T = function (t, n) {
      for (let r = 0, e = t.length; r < e; ++r) {
        if (!0 !== n(t[r], r)) return !1;
      }
      return !0;
    };
    const N = Object.keys;
    const P = Object.hasOwnProperty;
    const S =
      ((function (i) {
        if (!v(i)) throw new Error("cases must be an array");
        if (i.length === 0) throw new Error("there must be at least one case");
        const u = [];
          const r = {};
        C(i, function (t, e) {
          const n = N(t);
          if (n.length !== 1) throw new Error("one and only one name per case");
          const o = n[0];
            const a = t[o];
          if (r[o] !== undefined)
            throw new Error(`duplicate key detected:${  o}`);
          if (o === "cata")
            throw new Error("cannot have a case named cata (sorry)");
          if (!v(a)) throw new Error("case arguments must be an array");
          u.push(o),
            (r[o] = function () {
              const t = arguments.length;
              if (t !== a.length)
                throw new Error(
                  `Wrong number of arguments to case ${ 
                    o 
                    }. Expected ${ 
                    a.length 
                    } (${ 
                    a 
                    }), got ${ 
                    t}`
                );
              for (var r = new Array(t), n = 0; n < r.length; n++)
                r[n] = arguments[n];
              return {
                fold () {
                  if (arguments.length !== i.length)
                    throw new Error(
                      `Wrong number of arguments to fold. Expected ${ 
                        i.length 
                        }, got ${ 
                        arguments.length}`
                    );
                  return arguments[e].apply(null, r);
                },
                match (t) {
                  const n = N(t);
                  if (u.length !== n.length)
                    throw new Error(
                      `Wrong number of arguments to match. Expected: ${ 
                        u.join(",") 
                        }\nActual: ${ 
                        n.join(",")}`
                    );
                  if (
                    !T(u, function (t) {
                      return O(n, t);
                    })
                  )
                    throw new Error(
                      `Not all branches were specified when using match. Specified: ${ 
                        n.join(", ") 
                        }\nRequired: ${ 
                        u.join(", ")}`
                    );
                  return t[o].apply(null, r);
                },
                log (t) {
                  f.console.log(t, {
                    constructors: u,
                    constructor: o,
                    params: r,
                  });
                },
              };
            });
        });
      })([
        { bothErrors: ["error1", "error2"] },
        { firstError: ["error1", "value2"] },
        { secondError: ["value1", "error2"] },
        { bothValues: ["value1", "value2"] },
      ]),
      function (t) {
        const n = [];
          const r = [];
        return (
          C(t, function (t) {
            t.fold(
              function (t) {
                n.push(t);
              },
              function (t) {
                r.push(t);
              }
            );
          }),
          { errors: n, values: r }
        );
      });
    var M = function (r) {
      return {
        is (t) {
          return r === t;
        },
        isValue: s,
        isError: c,
        getOr: a(r),
        getOrThunk: a(r),
        getOrDie: a(r),
        or (t) {
          return M(r);
        },
        orThunk (t) {
          return M(r);
        },
        fold (t, n) {
          return n(r);
        },
        map (t) {
          return M(t(r));
        },
        mapError (t) {
          return M(r);
        },
        each (t) {
          t(r);
        },
        bind (t) {
          return t(r);
        },
        exists (t) {
          return t(r);
        },
        forall (t) {
          return t(r);
        },
        toOption () {
          return y.some(r);
        },
      };
    };
    var A = function (r) {
      return {
        is: c,
        isValue: c,
        isError: s,
        getOr: i,
        getOrThunk (t) {
          return t();
        },
        getOrDie () {
          return (
            (t = String(r)),
            (function () {
              throw new Error(t);
            })()
          );
          let t;
        },
        or (t) {
          return t;
        },
        orThunk (t) {
          return t();
        },
        fold (t, n) {
          return t(r);
        },
        map (t) {
          return A(r);
        },
        mapError (t) {
          return A(t(r));
        },
        each: o,
        bind (t) {
          return A(r);
        },
        exists: c,
        forall: s,
        toOption: y.none,
      };
    };
    const B = {
      value: M,
      error: A,
      fromOption (t, n) {
        return t.fold(function () {
          return A(n);
        }, M);
      },
    };
    const D = function (t) {
      return t.type === "inline-command" || t.type === "inline-format";
    };
    const I = function (t) {
      return t.type === "block-command" || t.type === "block-format";
    };
    const j = function (t) {
      return (
        (n = t),
        (r = function (t, n) {
          return t.start.length === n.start.length
            ? 0
            : t.start.length > n.start.length
            ? -1
            : 1;
        }),
        (e = b.call(n, 0)).sort(r),
        e
      );
      let n; let r; let e;
    };
    const _ = function (o) {
      const a = function (t) {
          return B.error({ message: t, pattern: o });
        };
        const t = function (t, n, r) {
          if (o.format === undefined)
            return o.cmd !== undefined
              ? p(o.cmd)
                ? B.value(r(o.cmd, o.value))
                : a(`${t  } pattern has non-string \`cmd\` parameter`)
              : a(`${t  } pattern is missing both \`format\` and \`cmd\` parameters`);
          let e = void 0;
          if (v(o.format)) {
            if (!T(o.format, p))
              return a(
                `${t  } pattern has non-string items in the \`format\` array`
              );
            e = o.format;
          } else {
            if (!p(o.format))
              return a(`${t  } pattern has non-string \`format\` parameter`);
            e = [o.format];
          }
          return B.value(n(e));
        };
      if (!h(o)) return a("Raw pattern is not an object");
      if (!p(o.start)) return a("Raw pattern is missing `start` parameter");
      if (o.end === undefined)
        return o.replacement !== undefined
          ? p(o.replacement)
            ? o.start.length === 0
              ? a("Replacement pattern has empty `start` parameter")
              : B.value({
                  type: "inline-command",
                  start: "",
                  end: o.start,
                  cmd: "mceInsertContent",
                  value: o.replacement,
                })
            : a("Replacement pattern has non-string `replacement` parameter")
          : o.start.length === 0
          ? a("Block pattern has empty `start` parameter")
          : t(
              "Block",
              function (t) {
                return { type: "block-format", start: o.start, format: t[0] };
              },
              function (t, n) {
                return {
                  type: "block-command",
                  start: o.start,
                  cmd: t,
                  value: n,
                };
              }
            );
      if (!p(o.end)) return a("Inline pattern has non-string `end` parameter");
      if (o.start.length === 0 && o.end.length === 0)
        return a("Inline pattern has empty `start` and `end` parameters");
      let r = o.start;
        let e = o.end;
      return (
        e.length === 0 && ((e = r), (r = "")),
        t(
          "Inline",
          function (t) {
            return { type: "inline-format", start: r, end: e, format: t };
          },
          function (t, n) {
            return {
              type: "inline-command",
              start: r,
              end: e,
              cmd: t,
              value: n,
            };
          }
        )
      );
    };
    const U = function (t) {
      return t.type === "block-command"
        ? { start: t.start, cmd: t.cmd, value: t.value }
        : t.type === "block-format"
        ? { start: t.start, format: t.format }
        : t.type === "inline-command"
        ? t.cmd === "mceInsertContent" && t.start === ""
          ? { start: t.end, replacement: t.value }
          : { start: t.start, end: t.end, cmd: t.cmd, value: t.value }
        : t.type === "inline-format"
        ? {
            start: t.start,
            end: t.end,
            format: t.format.length === 1 ? t.format[0] : t.format,
          }
        : void 0;
    };
    const q = function (t) {
      return { inlinePatterns: E(t, D), blockPatterns: j(E(t, I)) };
    };
    const L = function (e) {
      return {
        setPatterns (t) {
          const n = S(w(t, _));
          if (n.errors.length > 0) {
            const r = n.errors[0];
            throw new Error(
              `${r.message  }:\n${  JSON.stringify(r.pattern, null, 2)}`
            );
          }
          e.set(q(n.values));
        },
        getPatterns () {
          return (function f() {
            for (var t = 0, n = 0, r = arguments.length; n < r; n++)
              t += arguments[n].length;
            const e = Array(t);
              let o = 0;
            for (n = 0; n < r; n++)
              for (let a = arguments[n], i = 0, u = a.length; i < u; i++, o++)
                e[o] = a[i];
            return e;
          })(w(e.get().inlinePatterns, U), w(e.get().blockPatterns, U));
        },
      };
    };
    const V = typeof f.window !== "undefined" ? f.window : Function("return this;")();
    const W = function () {
      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
      const r = V.console;
      r && (r.error ? r.error.apply(r, t) : r.log.apply(r, t));
    };
    const F = [
      { start: "*", end: "*", format: "italic" },
      { start: "**", end: "**", format: "bold" },
      { start: "#", format: "h1" },
      { start: "##", format: "h2" },
      { start: "###", format: "h3" },
      { start: "####", format: "h4" },
      { start: "#####", format: "h5" },
      { start: "######", format: "h6" },
      { start: "1. ", cmd: "InsertOrderedList" },
      { start: "* ", cmd: "InsertUnorderedList" },
      { start: "- ", cmd: "InsertUnorderedList" },
    ];
    const G = function (t) {
      const n = t.getParam("forced_root_block", "p");
      return !1 === n ? "" : !0 === n ? "p" : n;
    };
    const H = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const J = tinymce.util.Tools.resolve("tinymce.util.VK");
    const K = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const X = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
    const z = tinymce.util.Tools.resolve("tinymce.dom.TextSeeker");
    const Q = function (t, n) {
      return { container: t, offset: n };
    };
    const Y = function (t) {
      return t.nodeType === f.Node.TEXT_NODE;
    };
    var Z = function (t, n, r) {
      if (n && t.isEmpty(n) && !r(n)) {
        const e = n.parentNode;
        t.remove(n), Z(t, e, r);
      }
    };
    const $ = function (t, n, r, e) {
      void 0 === e && (e = !0);
      const o = n.startContainer.parentNode;
        const a = n.endContainer.parentNode;
      n.deleteContents(),
        e &&
          !r(n.startContainer) &&
          (Y(n.startContainer) &&
            n.startContainer.data.length === 0 &&
            t.remove(n.startContainer),
          Y(n.endContainer) &&
            n.endContainer.data.length === 0 &&
            t.remove(n.endContainer),
          Z(t, o, r),
          o !== a && Z(t, a, r));
    };
    const tt = function (t, n) {
      let r;
        const e = n.get(t);
      return (
        v(e) &&
        ((r = e).length === 0 ? y.none() : y.some(r[0])).exists(function (t) {
          return (n = t), (r = "block"), P.call(n, r);
          let n; let r;
        })
      );
    };
    const nt = function (t) {
      return t.start.length === 0;
    };
    const rt = function (t, n) {
      const r = y.from(t.dom.getParent(n.startContainer, t.dom.isBlock));
      return G(t) === ""
        ? r.orThunk(function () {
            return y.some(t.getBody());
          })
        : r;
    };
    const et = X.DOM;
    const ot = function (n) {
      return function (t) {
        return n === t ? -1 : 0;
      };
    };
    const at = function (t, n, r) {
      if (Y(t) && n >= 0) return y.some(Q(t, n));
      const e = z(et);
      return y.from(e.backwards(t, n, ot(t), r)).map(function (t) {
        return Q(t.container, t.container.data.length);
      });
    };
    var it = function (t, r, e) {
      if (!Y(t)) return y.none();
      const n = t.textContent;
      if (r >= 0 && r <= n.length) return y.some(Q(t, r));
      const o = z(et);
      return y.from(o.backwards(t, r, ot(t), e)).bind(function (t) {
        const n = t.container.data;
        return it(t.container, r + n.length, e);
      });
    };
    var ut = function (t, n, r) {
      if (!Y(t)) return y.none();
      const e = t.textContent;
      if (n <= e.length) return y.some(Q(t, n));
      const o = z(et);
      return y.from(o.forwards(t, n, ot(t), r)).bind(function (t) {
        return ut(t.container, n - e.length, r);
      });
    };
    const ft = function (t, n, r, e, o) {
      let a;
        const i = z(
          t,
          ((a = t),
          function (t) {
            return (
              a.isBlock(t) ||
              O(["BR", "IMG", "HR", "INPUT"], t.nodeName) ||
              a.getContentEditable(t) === "false"
            );
          })
        );
      return y.from(i.backwards(n, r, e, o));
    };
    const ct = function (t, n, r) {
      if (Y(n) && (r < 0 || r > n.data.length)) return [];
      for (var e = [r], o = n; o !== t && o.parentNode; ) {
        for (var a = o.parentNode, i = 0; i < a.childNodes.length; i++)
          if (a.childNodes[i] === o) {
            e.push(i);
            break;
          }
        o = a;
      }
      return o === t ? e.reverse() : [];
    };
    const st = function (t, n, r, e, o) {
      return { start: ct(t, n, r), end: ct(t, e, o) };
    };
    const lt = function (t, n) {
      let r;
        let e;
        let o;
        const a = n.slice();
        const i = a.pop();
      return (
        (r = a),
        (e = function (t, n) {
          return t.bind(function (t) {
            return y.from(t.childNodes[n]);
          });
        }),
        (o = y.some(t)),
        C(r, function (t) {
          o = e(o, t);
        }),
        o.bind(function (t) {
          return (
            Y(t) && i >= 0 && t.data.length, y.some({ node: t, offset: i })
          );
        })
      );
    };
    const dt = function (n, r) {
      return lt(n, r.start).bind(function (t) {
        const o = t.node;
          const a = t.offset;
        return lt(n, r.end).map(function (t) {
          const n = t.node;
            const r = t.offset;
            const e = f.document.createRange();
          return e.setStart(o, a), e.setEnd(n, r), e;
        });
      });
    };
    const mt = function (e, o, n) {
      (function (t, n, r) {
        if (Y(t) && n >= t.length) return y.some(Q(t, n));
        const e = z(et);
        return y.from(e.forwards(t, n, ot(t), r)).map(function (t) {
          return Q(t.container, 0);
        });
      })(o, 0, o).each(function (t) {
        const r = t.container;
        ut(r, n.start.length, o).each(function (t) {
          const n = e.createRng();
          n.setStart(r, 0),
            n.setEnd(t.container, t.offset),
            $(e, n, function (t) {
              return t === o;
            });
        });
      });
    };
    const gt = function (e, a) {
      const i = e.dom;
        const t = e.selection.getRng();
      return rt(e, t)
        .filter(function (t) {
          const n = G(e);
            const r = (n === "" && i.is(t, "body")) || i.is(t, n);
          return t !== null && r;
        })
        .bind(function (n) {
          let t;
            let r;
            let e;
            const o = n.textContent;
          return ((t = a),
          (e = (r = o).replace("\xa0", " ")),
          R(t, function (t) {
            return r.indexOf(t.start) === 0 || e.indexOf(t.start) === 0;
          })).map(function (t) {
            return K.trim(o).length === t.start.length
              ? []
              : [{ pattern: t, range: st(i.getRoot(), n, 0, n, 0) }];
          });
        })
        .getOr([]);
    };
    const pt = function (i, t) {
      if (t.length !== 0) {
        const n = i.selection.getBookmark();
        C(t, function (t) {
          return (
            (r = t),
            (e = (n = i).dom),
            (o = r.pattern),
            (a = dt(e.getRoot(), r.range).getOrDie(
              "Unable to resolve path range"
            )),
            rt(n, a).each(function (t) {
              o.type === "block-format"
                ? tt(o.format, n.formatter) &&
                  n.undoManager.transact(function () {
                    mt(n.dom, t, o), n.formatter.apply(o.format);
                  })
                : o.type === "block-command" &&
                  n.undoManager.transact(function () {
                    mt(n.dom, t, o), n.execCommand(o.cmd, !1, o.value);
                  });
            }),
            1
          );
          let n; let r; let e; let o; let a;
        }),
          i.selection.moveToBookmark(n);
      }
    };
    let ht = 0;
    const vt = function (t, n) {
      return t.create("span", { "data-mce-type": "bookmark", id: n });
    };
    const yt = function (t, n) {
      const r = t.createRng();
      return r.setStartAfter(n.start), r.setEndBefore(n.end), r;
    };
    const bt = function (t, n, r) {
      const e = dt(t.getRoot(), r).getOrDie("Unable to resolve path range");
        const o = e.startContainer;
        const a = e.endContainer;
        const i = e.endOffset === 0 ? a : a.splitText(e.endOffset);
        const u = e.startOffset === 0 ? o : o.splitText(e.startOffset);
      return {
        prefix: n,
        end: i.parentNode.insertBefore(vt(t, `${n  }-end`), i),
        start: u.parentNode.insertBefore(vt(t, `${n  }-start`), u),
      };
    };
    const kt = function (t, n, r) {
      Z(t, t.get(`${n.prefix  }-end`), r), Z(t, t.get(`${n.prefix  }-start`), r);
    };
    var Ot = function (e, o, a, t) {
      let i;
        const u = o.start;
      return ft(
        e,
        t.container,
        t.offset,
        ((i = u),
        function (t, n) {
          const r = t.data.substring(0, n);
            const e = r.lastIndexOf(i.charAt(i.length - 1));
            const o = r.lastIndexOf(i);
          return o !== -1 ? o + i.length : e !== -1 ? e + 1 : -1;
        }),
        a
      ).bind(function (r) {
        if (r.offset >= u.length) {
          const t = e.createRng();
          return (
            t.setStart(r.container, r.offset - u.length),
            t.setEnd(r.container, r.offset),
            y.some(t)
          );
        }
        const n = r.offset - u.length;
        return it(r.container, n, a)
          .map(function (t) {
            const n = e.createRng();
            return (
              n.setStart(t.container, t.offset),
              n.setEnd(r.container, r.offset),
              n
            );
          })
          .filter(function (t) {
            return t.toString() === u;
          })
          .orThunk(function () {
            return Ot(e, o, a, Q(r.container, 0));
          });
      });
    };
    const wt = function (a, i, u) {
      const f = a.dom;
        const c = f.getRoot();
        const s = u.pattern;
        const l = u.position.container;
        const d = u.position.offset;
      return it(l, d - u.pattern.end.length, i).bind(function (t) {
        const e = st(c, t.container, t.offset, l, d);
        if (nt(s))
          return y.some({
            matches: [{ pattern: s, startRng: e, endRng: e }],
            position: t,
          });
        const n = Ct(a, u.remainingPatterns, t.container, t.offset, i);
          const o = n.getOr({ matches: [], position: t });
          const r = o.position;
        return (function (t, r, n, e, o, a) {
          if ((void 0 === a && (a = !1), r.start.length !== 0 || a))
            return at(n, e, o).bind(function (n) {
              return Ot(t, r, o, n).bind(function (t) {
                if (a) {
                  if (
                    t.endContainer === n.container &&
                    t.endOffset === n.offset
                  )
                    return y.none();
                  if (
                    n.offset === 0 &&
                    t.endContainer.textContent.length === t.endOffset
                  )
                    return y.none();
                }
                return y.some(t);
              });
            });
          const i = t.createRng();
          return i.setStart(n, e), i.setEnd(n, e), y.some(i);
        })(f, s, r.container, r.offset, i, n.isNone()).map(function (t) {
          let n;
            const r = st(
              c,
              (n = t).startContainer,
              n.startOffset,
              n.endContainer,
              n.endOffset
            );
          return {
            matches: o.matches.concat([{ pattern: s, startRng: r, endRng: e }]),
            position: Q(t.startContainer, t.startOffset),
          };
        });
      });
    };
    var Ct = function (d, m, g, p, h) {
      const v = d.dom;
      return at(g, p, v.getRoot()).bind(function (t) {
        const n = v.createRng();
        n.setStart(h, 0), n.setEnd(g, p);
        for (var r, e, o, a, i, u = n.toString(), f = 0; f < m.length; f++) {
          const c = m[f];
          if (
            ((r = u),
            (e = c.end),
            (i = a = o = void 0),
            (a = e),
            (i = (o = r).length - e.length),
            a === "" ||
              (o.length >= a.length && o.substr(i, i + a.length) === a))
          ) {
            const s = m.slice();
            s.splice(f, 1);
            const l = wt(d, h, { pattern: c, remainingPatterns: s, position: t });
            if (l.isSome()) return l;
          }
        }
        return y.none();
      });
    };
    const Et = function (n, t, r) {
      n.selection.setRng(r),
        t.type === "inline-format"
          ? C(t.format, function (t) {
              n.formatter.apply(t);
            })
          : n.execCommand(t.cmd, !1, t.value);
    };
    const xt = function (o, t) {
      let n;
        let r;
        const a =
          ((n = "mce_textpattern"),
          (r = new Date().getTime()),
          `${n  }_${  Math.floor(1e9 * Math.random())  }${++ht  }${String(r)}`);
        const i = x(
          t,
          function (t, n) {
            const r = bt(o, `${a  }_end${  t.length}`, n.endRng);
            return t.concat([{...n, endMarker: r}]);
          },
          []
        );
      return x(
        i,
        function (t, n) {
          const r = i.length - t.length - 1;
            const e = nt(n.pattern)
              ? n.endMarker
              : bt(o, `${a  }_start${  r}`, n.startRng);
          return t.concat([{...n, startMarker: e}]);
        },
        []
      );
    };
    const Rt = function (r, e, o) {
      const a = r.selection.getRng();
      return !1 === a.collapsed
        ? []
        : rt(r, a)
            .bind(function (t) {
              const n = a.startOffset - (o ? 1 : 0);
              return Ct(r, e, a.startContainer, n, t);
            })
            .fold(
              function () {
                return [];
              },
              function (t) {
                return t.matches;
              }
            );
    };
    const Tt = function (f, t) {
      if (t.length !== 0) {
        const c = f.dom;
          const n = f.selection.getBookmark();
          const r = xt(c, t);
        C(r, function (t) {
          let n;
            let r;
            let e;
            let o;
            let a;
            const i = c.getParent(t.startMarker.start, c.isBlock);
            const u = function (t) {
              return t === i;
            };
          nt(t.pattern)
            ? ((n = f),
              (r = t.pattern),
              (e = t.endMarker),
              (o = u),
              (a = yt(n.dom, e)),
              $(n.dom, a, o),
              Et(n, r, a))
            : (function (t, n, r, e, o) {
                const a = t.dom;
                  const i = yt(a, e);
                  const u = yt(a, r);
                $(a, u, o), $(a, i, o);
                const f = { prefix: r.prefix, start: r.end, end: e.start };
                  const c = yt(a, f);
                Et(t, n, c);
              })(f, t.pattern, t.startMarker, t.endMarker, u),
            kt(c, t.endMarker, u),
            kt(c, t.startMarker, u);
        }),
          f.selection.moveToBookmark(n);
      }
    };
    const Nt = function (t, n) {
      const r = Rt(t, n.inlinePatterns, !0);
      r.length > 0 &&
        t.undoManager.transact(function () {
          Tt(t, r);
        });
    };
    const Pt = function (t, n, r) {
      for (let e = 0; e < t.length; e++) if (r(t[e], n)) return !0;
    };
    const St = function (n, r) {
      const e = [",", ".", ";", ":", "!", "?"];
        const o = [32];
      n.on(
        "keydown",
        function (t) {
          t.keyCode !== 13 ||
            J.modifierPressed(t) ||
            !(function (r, t) {
              if (!r.selection.isCollapsed()) return !1;
              const e = Rt(r, t.inlinePatterns, !1);
                const o = gt(r, t.blockPatterns);
              return (
                (o.length > 0 || e.length > 0) &&
                (r.undoManager.add(),
                r.undoManager.extra(
                  function () {
                    r.execCommand("mceInsertNewLine");
                  },
                  function () {
                    r.insertContent("\ufeff"), Tt(r, e), pt(r, o);
                    const t = r.selection.getRng();
                      const n = at(t.startContainer, t.startOffset, r.dom.getRoot());
                    r.execCommand("mceInsertNewLine"),
                      n.each(function (t) {
                        const n = t.container;
                        n.data.charAt(t.offset - 1) === "\ufeff" &&
                          (n.deleteData(t.offset - 1, 1),
                          Z(r.dom, n.parentNode, function (t) {
                            return t === r.dom.getRoot();
                          }));
                      });
                  }
                ),
                !0)
              );
            })(n, r.get()) ||
            t.preventDefault();
        },
        !0
      ),
        n.on("keyup", function (t) {
          Pt(o, t, function (t, n) {
            return t === n.keyCode && !1 === J.modifierPressed(n);
          }) && Nt(n, r.get());
        }),
        n.on("keypress", function (t) {
          Pt(e, t, function (t, n) {
            return t.charCodeAt(0) === n.charCode;
          }) &&
            H.setEditorTimeout(n, function () {
              Nt(n, r.get());
            });
        });
    };
  !(function Mt() {
    t.add("textpattern", function (t) {
      let n;
        let r;
        const e =
          ((n = (function (t) {
            const n = t.getParam("textpattern_patterns", F, "array");
            if (!v(n))
              return (
                W("The setting textpattern_patterns should be an array"),
                { inlinePatterns: [], blockPatterns: [] }
              );
            const r = S(w(n, _));
            return (
              C(r.errors, function (t) {
                return W(t.message, t.pattern);
              }),
              q(r.values)
            );
          })(t)),
          (r = n),
          {
            get () {
              return r;
            },
            set (t) {
              r = t;
            },
          });
      return St(t, e), L(e);
    });
  })();
})(window);
