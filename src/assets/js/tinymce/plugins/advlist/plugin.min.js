/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.4.1 (2020-07-08)
 */
!(function () {
  
  let n;
    let t;
    let e;
    const r = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const l = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const c = function (n, t, e) {
      const r = t === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
      n.execCommand(r, !1, !1 === e ? null : { "list-style-type": e });
    };
    const i = function (n) {
      return function () {
        return n;
      };
    };
    const u = i(!1);
    const s = i(!0);
    const o = function () {
      return a;
    };
    var a =
      ((n = function (n) {
        return n.isNone();
      }),
      {
        fold (n, t) {
          return n();
        },
        is: u,
        isSome: u,
        isNone: s,
        getOr: (e = function (n) {
          return n;
        }),
        getOrThunk: (t = function (n) {
          return n();
        }),
        getOrDie (n) {
          throw new Error(n || "error: getOrDie called on none.");
        },
        getOrNull: i(null),
        getOrUndefined: i(undefined),
        or: e,
        orThunk: t,
        map: o,
        each () {},
        bind: o,
        exists: u,
        forall: s,
        filter: o,
        equals: n,
        equals_: n,
        toArray () {
          return [];
        },
        toString: i("none()"),
      });
    var f = function (e) {
      const n = i(e);
        const t = function () {
          return o;
        };
        const r = function (n) {
          return n(e);
        };
        var o = {
          fold (n, t) {
            return t(e);
          },
          is (n) {
            return e === n;
          },
          isSome: s,
          isNone: u,
          getOr: n,
          getOrThunk: n,
          getOrDie: n,
          getOrNull: n,
          getOrUndefined: n,
          or: t,
          orThunk: t,
          map (n) {
            return f(n(e));
          },
          each (n) {
            n(e);
          },
          bind: r,
          exists: r,
          forall: r,
          filter (n) {
            return n(e) ? o : a;
          },
          toArray () {
            return [e];
          },
          toString () {
            return `some(${  e  })`;
          },
          equals (n) {
            return n.is(e);
          },
          equals_ (n, t) {
            return n.fold(u, function (n) {
              return t(e, n);
            });
          },
        };
      return o;
    };
    const d = function (n) {
      return n === null || n === undefined ? a : f(n);
    };
    const g = function (n) {
      return n && /^(TH|TD)$/.test(n.nodeName);
    };
    const m = function (r) {
      return function (n) {
        return (
          n &&
          /^(OL|UL|DL)$/.test(n.nodeName) &&
          ((e = n), (t = r).$.contains(t.getBody(), e))
        );
        let t; let e;
      };
    };
    const p = function (n, t, e) {
      const r = (function (n, t) {
          for (let e = 0; e < n.length; e++) {
            if (t(n[e])) return e;
          }
          return -1;
        })(t.parents, g);
        const o = r !== -1 ? t.parents.slice(0, r) : t.parents;
        const i = l.grep(o, m(n));
      return i.length > 0 && i[0].nodeName === e;
    };
    const y = function (o, n, t, e, r, i) {
      o.ui.registry.addSplitButton(n, {
        tooltip: t,
        icon: r === "OL" ? "ordered-list" : "unordered-list",
        presets: "listpreview",
        columns: 3,
        fetch (n) {
          n(
            l.map(i, function (n) {
              return {
                type: "choiceitem",
                value: n === "default" ? "" : n,
                icon:
                  `list-${ 
                  r === "OL" ? "num" : "bull" 
                  }-${ 
                  n === "disc" || n === "decimal" ? "default" : n}`,
                text: n.replace(/\-/g, " ").replace(/\b\w/g, function (n) {
                  return n.toUpperCase();
                }),
              };
            })
          );
        },
        onAction () {
          return o.execCommand(e);
        },
        onItemAction (n, t) {
          c(o, r, t);
        },
        select (t) {
          let n; let e; let r;
          return ((e = (n = o).dom.getParent(n.selection.getNode(), "ol,ul")),
          (r = n.dom.getStyle(e, "listStyleType")),
          d(r))
            .map(function (n) {
              return t === n;
            })
            .getOr(!1);
        },
        onSetup (t) {
          const n = function (n) {
            t.setActive(p(o, n, r));
          };
          return (
            o.on("NodeChange", n),
            function () {
              return o.off("NodeChange", n);
            }
          );
        },
      });
    };
    const v = function (n, t, e, r, o, i) {
      let u; let l; let c; let s; let a;
      i.length > 1
        ? y(n, t, e, r, o, i)
        : ((l = t),
          (c = e),
          (s = r),
          (a = o),
          (u = n).ui.registry.addToggleButton(l, {
            active: !1,
            tooltip: c,
            icon: a === "OL" ? "ordered-list" : "unordered-list",
            onSetup (t) {
              const n = function (n) {
                t.setActive(p(u, n, a));
              };
              return (
                u.on("NodeChange", n),
                function () {
                  return u.off("NodeChange", n);
                }
              );
            },
            onAction () {
              return u.execCommand(s);
            },
          }));
    };
  !(function O() {
    r.add("advlist", function (n) {
      let e; let t; let r; let o; let i; let u;
      (i = n),
        (u = "lists"),
        l.inArray(i.getParam("plugins", "", "string").split(/[ ,]/), u) !==
          -1 &&
          (v(
            (t = n),
            "numlist",
            "Numbered list",
            "InsertOrderedList",
            "OL",
            (r = t.getParam(
              "advlist_number_styles",
              "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman"
            ))
              ? r.split(/[ ,]/)
              : []
          ),
          v(
            t,
            "bullist",
            "Bullet list",
            "InsertUnorderedList",
            "UL",
            (o = t.getParam("advlist_bullet_styles", "default,circle,square"))
              ? o.split(/[ ,]/)
              : []
          ),
          (e = n).addCommand("ApplyUnorderedListStyle", function (n, t) {
            c(e, "UL", t["list-style-type"]);
          }),
          e.addCommand("ApplyOrderedListStyle", function (n, t) {
            c(e, "OL", t["list-style-type"]);
          }));
    });
  })();
})();
