/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.4.1 (2020-07-08)
 */
!(function (p) {
  
  let n;
    let t;
    let e;
    const c = function (n) {
      let t = n;
      return {
        get () {
          return t;
        },
        set (n) {
          t = n;
        },
      };
    };
    const r = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const i = function (n) {
      return {
        isFullscreen () {
          return n.get() !== null;
        },
      };
    };
    const o = function () {};
    const a = function (n) {
      return function () {
        return n;
      };
    };
    const f = a(!1);
    const u = a(!0);
    const l = function () {
      return d;
    };
    var d =
      ((n = function (n) {
        return n.isNone();
      }),
      {
        fold (n, t) {
          return n();
        },
        is: f,
        isSome: f,
        isNone: u,
        getOr: (e = function (n) {
          return n;
        }),
        getOrThunk: (t = function (n) {
          return n();
        }),
        getOrDie (n) {
          throw new Error(n || "error: getOrDie called on none.");
        },
        getOrNull: a(null),
        getOrUndefined: a(undefined),
        or: e,
        orThunk: t,
        map: l,
        each: o,
        bind: l,
        exists: f,
        forall: u,
        filter: l,
        equals: n,
        equals_: n,
        toArray () {
          return [];
        },
        toString: a("none()"),
      });
    var s = function (e) {
      const n = a(e);
        const t = function () {
          return o;
        };
        const r = function (n) {
          return n(e);
        };
        var o = {
          fold (n, t) {
            return t(e);
          },
          is (n) {
            return e === n;
          },
          isSome: u,
          isNone: f,
          getOr: n,
          getOrThunk: n,
          getOrDie: n,
          getOrNull: n,
          getOrUndefined: n,
          or: t,
          orThunk: t,
          map (n) {
            return s(n(e));
          },
          each (n) {
            n(e);
          },
          bind: r,
          exists: r,
          forall: r,
          filter (n) {
            return n(e) ? o : d;
          },
          toArray () {
            return [e];
          },
          toString () {
            return `some(${  e  })`;
          },
          equals (n) {
            return n.is(e);
          },
          equals_ (n, t) {
            return n.fold(f, function (n) {
              return t(e, n);
            });
          },
        };
      return o;
    };
    const m = {
      some: s,
      none: l,
      from (n) {
        return n === null || n === undefined ? d : s(n);
      },
    };
    const h = function () {
      return (
        (n = function (n) {
          n.unbind();
        }),
        (t = c(m.none())),
        (e = function () {
          t.get().each(n);
        }),
        {
          clear () {
            e(), t.set(m.none());
          },
          isSet () {
            return t.get().isSome();
          },
          set (n) {
            e(), t.set(m.some(n));
          },
        }
      );
      let n; let t; let e;
    };
    const g = function (r) {
      return function (n) {
        return (
          (e = typeof (t = n)),
          (t === null
            ? "null"
            : e == "object" &&
              (Array.prototype.isPrototypeOf(t) ||
                (t.constructor && t.constructor.name === "Array"))
            ? "array"
            : e == "object" &&
              (String.prototype.isPrototypeOf(t) ||
                (t.constructor && t.constructor.name === "String"))
            ? "string"
            : e) === r
        );
        let t; let e;
      };
    };
    const v = function (t) {
      return function (n) {
        return typeof n === t;
      };
    };
    const y = g("string");
    const w = g("array");
    const b = v("boolean");
    const S = function (n) {
      return !((t = n) === null || t === undefined);
      let t;
    };
    const T = v("function");
    const x = v("number");
    const D = Array.prototype.push;
    const E = function (n, t) {
      for (var e = n.length, r = new Array(e), o = 0; o < e; o++) {
        const u = n[o];
        r[o] = t(u, o);
      }
      return r;
    };
    const A = function (n, t) {
      for (let e = 0, r = n.length; e < r; e++) {
        t(n[e], e);
      }
    };
    const N = function (n, t) {
      for (var e = [], r = 0, o = n.length; r < o; r++) {
        const u = n[r];
        t(u, r) && e.push(u);
      }
      return e;
    };
    const O = function (n, t) {
      return (function (n) {
        for (var t = [], e = 0, r = n.length; e < r; ++e) {
          if (!w(n[e]))
            throw new Error(
              `Arr.flatten item ${  e  } was not an array, input: ${  n}`
            );
          D.apply(t, n[e]);
        }
        return t;
      })(E(n, t));
    };
    const C = Object.keys;
    const M = function (n) {
      return n.style !== undefined && T(n.style.getPropertyValue);
    };
    const k = function (n) {
      if (n === null || n === undefined)
        throw new Error("Node cannot be null or undefined");
      return { dom: a(n) };
    };
    const F = {
      fromHtml (n, t) {
        const e = (t || p.document).createElement("div");
        if (((e.innerHTML = n), !e.hasChildNodes() || e.childNodes.length > 1))
          throw (
            (p.console.error("HTML does not have a single root node", n),
            new Error("HTML must have a single root node"))
          );
        return k(e.childNodes[0]);
      },
      fromTag (n, t) {
        const e = (t || p.document).createElement(n);
        return k(e);
      },
      fromText (n, t) {
        const e = (t || p.document).createTextNode(n);
        return k(e);
      },
      fromDom: k,
      fromPoint (n, t, e) {
        const r = n.dom();
        return m.from(r.elementFromPoint(t, e)).map(k);
      },
    };
    const P =
      (typeof p.window !== "undefined" ? p.window : Function("return this;")(),
      function (t) {
        return function (n) {
          return n.dom().nodeType === t;
        };
      });
    const L = P(1);
    const H = P(3);
    const q = P(9);
    const V = P(11);
    const W = function (n, t) {
      const e = n.dom();
      if (e.nodeType !== 1) return !1;
      const r = e;
      if (r.matches !== undefined) return r.matches(t);
      if (r.msMatchesSelector !== undefined) return r.msMatchesSelector(t);
      if (r.webkitMatchesSelector !== undefined)
        return r.webkitMatchesSelector(t);
      if (r.mozMatchesSelector !== undefined) return r.mozMatchesSelector(t);
      throw new Error("Browser lacks native selectors");
    };
    const j = function (e) {
      let n;
      return (
        (n = e),
        m
          .from(n.dom().parentNode)
          .map(F.fromDom)
          .map(z)
          .map(function (n) {
            return N(n, function (n) {
              return (t = n), e.dom() !== t.dom();
              let t;
            });
          })
          .getOr([])
      );
    };
    var z = function (n) {
      return E(n.dom().childNodes, F.fromDom);
    };
    const B = T(p.Element.prototype.attachShadow) && T(p.Node.prototype.getRootNode);
    const I = a(B);
    const R = B
      ? function (n) {
          return F.fromDom(n.dom().getRootNode());
        }
      : function (n) {
          return q(n) ? n : ((t = n), F.fromDom(t.dom().ownerDocument));
          let t;
        };
    const U = function (n) {
      const t = R(n);
      return V(t) ? m.some(t) : m.none();
    };
    const _ = function (n) {
      return F.fromDom(n.dom().host);
    };
    const K = function (n) {
      if (I() && S(n.target)) {
        const t = F.fromDom(n.target);
        if (L(t) && X(F.fromDom(n.target))) {
          if (n.composed && n.composedPath) {
            const e = n.composedPath();
            if (e) return (r = e).length === 0 ? m.none() : m.some(r[0]);
          }
        }
      }
      let r;
      return m.from(n.target);
    };
    var X = function (n) {
      return S(n.dom().shadowRoot);
    };
    var Y = function (n) {
      let t;
        let e;
        const r = H(n) ? n.dom().parentNode : n.dom();
      return (
        r !== undefined &&
        r !== null &&
        r.ownerDocument !== null &&
        U(F.fromDom(r)).fold(
          function () {
            return r.ownerDocument.body.contains(r);
          },
          ((t = Y),
          (e = _),
          function (n) {
            return t(e(n));
          })
        )
      );
    };
    const G = function (n, t, e) {
      !(function (n, t, e) {
        if (!(y(e) || b(e) || x(e)))
          throw (
            (p.console.error(
              "Invalid call to Attr.set. Key ",
              t,
              ":: Value ",
              e,
              ":: Element ",
              n
            ),
            new Error("Attribute value was not simple"))
          );
        n.setAttribute(t, `${e  }`);
      })(n.dom(), t, e);
    };
    const J = function (n, t) {
      const e = n.dom().getAttribute(t);
      return e === null ? undefined : e;
    };
    const Q = function (n, t) {
      n.dom().removeAttribute(t);
    };
    const Z = function (n, t) {
      const e = n.dom();
      !(function (n, t) {
        for (let e = C(n), r = 0, o = e.length; r < o; r++) {
          const u = e[r];
          t(n[u], u);
        }
      })(t, function (n, t) {
        !(function (n, t, e) {
          if (!y(e))
            throw (
              (p.console.error(
                "Invalid call to CSS.set. Property ",
                t,
                ":: Value ",
                e,
                ":: Element ",
                n
              ),
              new Error(`CSS value must be a string: ${  e}`))
            );
          M(n) && n.style.setProperty(t, e);
        })(e, t, n);
      });
    };
    const $ = function (n, t) {
      return M(n) ? n.style.getPropertyValue(t) : "";
    };
    const nn = function (n) {
      let e;
        let r;
        let t;
        let o;
        let u;
        const i = F.fromDom(K(n).getOr(n.target));
        const c = function () {
          return n.stopPropagation();
        };
        const f = function () {
          return n.preventDefault();
        };
        const l =
          ((e = f),
          (r = c),
          function () {
            for (var n = [], t = 0; t < arguments.length; t++)
              n[t] = arguments[t];
            return e(r.apply(null, n));
          });
      return (
        (t = i),
        (o = n.clientX),
        (u = n.clientY),
        {
          target: a(t),
          x: a(o),
          y: a(u),
          stop: c,
          prevent: f,
          kill: l,
          raw: a(n),
        }
      );
    };
    var tn = function (e, r) {
      return {
        left: a(e),
        top: a(r),
        translate (n, t) {
          return tn(e + n, r + t);
        },
      };
    };
    const en = tn;
    const rn = function (n) {
      const t = n === undefined ? p.window : n;
      return m.from(t.visualViewport);
    };
    const on = function (n, t, e, r) {
      return { x: n, y: t, width: e, height: r, right: n + e, bottom: t + r };
    };
    const un = function (n) {
      let t;
        let e;
        let r;
        let o;
        const u = n === undefined ? p.window : n;
        const i = u.document;
        const c =
          ((t = F.fromDom(i)),
          (e = t !== undefined ? t.dom() : p.document),
          (r = e.body.scrollLeft || e.documentElement.scrollLeft),
          (o = e.body.scrollTop || e.documentElement.scrollTop),
          en(r, o));
      return rn(u).fold(
        function () {
          const n = u.document.documentElement;
            const t = n.clientWidth;
            const e = n.clientHeight;
          return on(c.left(), c.top(), t, e);
        },
        function (n) {
          return on(
            Math.max(n.pageLeft, c.left()),
            Math.max(n.pageTop, c.top()),
            n.width,
            n.height
          );
        }
      );
    };
    const cn = function (e, n, t) {
      return rn(t)
        .map(function (n) {
          const t = function (n) {
            return nn(n);
          };
          return (
            n.addEventListener(e, t),
            {
              unbind () {
                return n.removeEventListener(e, t);
              },
            }
          );
        })
        .getOrThunk(function () {
          return { unbind: o };
        });
    };
    const fn = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
    const ln = tinymce.util.Tools.resolve("tinymce.Env");
    const an = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const dn = function (n, t) {
      n.fire("FullscreenStateChanged", { state: t });
    };
    const sn = function (n, t, e) {
      return N(
        (function (n, t) {
          for (
            var e = T(t) ? t : f, r = n.dom(), o = [];
            r.parentNode !== null && r.parentNode !== undefined;

          ) {
            const u = r.parentNode;
              const i = F.fromDom(u);
            if ((o.push(i), !0 === e(i))) break;
            r = u;
          }
          return o;
        })(n, e),
        t
      );
    };
    const mn = function (n) {
      return (
        (t = n),
        (o = e === undefined ? p.document : e.dom()),
        ((r = o).nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11) ||
        r.childElementCount === 0
          ? []
          : E(o.querySelectorAll(t), F.fromDom)
      );
      let t; let e; let r; let o;
    };
    const hn = function (n, t) {
      return (
        (e = function (n) {
          return W(n, t);
        }),
        N(j(n), e)
      );
      let e;
    };
    const pn = "data-ephox-mobile-fullscreen-style";
    const gn = "position:absolute!important;";
    const vn =
      "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;";
    const yn = ln.os.isAndroid();
    const wn = function (n) {
      let t;
        let e;
        let r;
        let o;
        const u =
          ((e = "background-color"),
          (r = (t = n).dom()),
          (o = p.window.getComputedStyle(r).getPropertyValue(e)) !== "" || Y(t)
            ? o
            : $(r, e));
      return u !== undefined && u !== ""
        ? `background-color:${  u  }!important`
        : "background-color:rgb(255,255,255)!important;";
    };
    const bn = function (o, n, t) {
      let e;
        let r;
        const u = function (r) {
          return function (n) {
            const t = J(n, "style");
              const e = t === undefined ? "no-styles" : t.trim();
            e !== r && (G(n, pn, e), Z(n, o.parseStyle(r)));
          };
        };
        const i =
          ((e = "*"),
          sn(
            n,
            function (n) {
              return W(n, e);
            },
            r
          ));
        const c = O(i, function (n) {
          return hn(n, "*:not(.tox-silver-sink)");
        });
        const f = wn(t);
      A(c, u("display:none!important;")),
        A(i, u(gn + vn + f)),
        u((!0 === yn ? "" : gn) + vn + f)(n);
    };
    const Sn = fn.DOM;
    const Tn = rn().fold(
      function () {
        return { bind: o, unbind: o };
      },
      function (t) {
        let e;
          const r =
            ((e = c(m.none())),
            {
              clear () {
                e.set(m.none());
              },
              set (n) {
                e.set(m.some(n));
              },
              isSet () {
                return e.get().isSome();
              },
              on (n) {
                e.get().each(n);
              },
            });
          const o = h();
          const u = h();
          const i = an.throttle(function () {
            (p.document.body.scrollTop = 0),
              (p.document.documentElement.scrollTop = 0),
              p.window.requestAnimationFrame(function () {
                r.on(function (n) {
                  return Z(n, {
                    top: `${t.offsetTop  }px`,
                    left: `${t.offsetLeft  }px`,
                    height: `${t.height  }px`,
                    width: `${t.width  }px`,
                  });
                });
              });
          }, 50);
        return {
          bind (n) {
            r.set(n), i(), o.set(cn("resize")), u.set(cn("scroll"));
          },
          unbind () {
            r.on(function () {
              o.clear(), u.clear();
            }),
              r.clear();
          },
        };
      }
    );
    const xn = function (t, n) {
      let e;
        let r;
        const o = p.document.body;
        const u = p.document.documentElement;
        const i = t.getContainer();
        const c = F.fromDom(i);
        const f = n.get();
        const l = F.fromDom(t.getBody());
        const a = ln.deviceType.isTouch();
        const d = i.style;
        const s = t.iframeElement.style;
        const m = function () {
          let e; let n;
          a &&
            ((e = t.dom),
            (n = mn(`[${  pn  }]`)),
            A(n, function (n) {
              const t = J(n, pn);
              t !== "no-styles" ? Z(n, e.parseStyle(t)) : Q(n, "style"),
                Q(n, pn);
            })),
            Sn.removeClass(o, "tox-fullscreen"),
            Sn.removeClass(u, "tox-fullscreen"),
            Sn.removeClass(i, "tox-fullscreen"),
            Tn.unbind();
        };
      if (f)
        (s.width = f.iframeWidth),
          (s.height = f.iframeHeight),
          (d.width = f.containerWidth),
          (d.height = f.containerHeight),
          (d.top = f.containerTop),
          (d.left = f.containerLeft),
          (e = f.scrollPos),
          p.window.scrollTo(e.x, e.y),
          n.set(null),
          dn(t, !1),
          m(),
          t.off("remove", m);
      else {
        const h = {
          scrollPos: { x: (r = un(p.window)).x, y: r.y },
          containerWidth: d.width,
          containerHeight: d.height,
          containerTop: d.top,
          containerLeft: d.left,
          iframeWidth: s.width,
          iframeHeight: s.height,
        };
        a && bn(t.dom, c, l),
          (s.width = s.height = "100%"),
          (d.width = d.height = ""),
          Sn.addClass(o, "tox-fullscreen"),
          Sn.addClass(u, "tox-fullscreen"),
          Sn.addClass(i, "tox-fullscreen"),
          Tn.bind(c),
          t.on("remove", m),
          n.set(h),
          dn(t, !0);
      }
    };
    const Dn = function (e, r) {
      return function (t) {
        t.setActive(r.get() !== null);
        const n = function (n) {
          return t.setActive(n.state);
        };
        return (
          e.on("FullscreenStateChanged", n),
          function () {
            return e.off("FullscreenStateChanged", n);
          }
        );
      };
    };
  !(function En() {
    r.add("fullscreen", function (n) {
      let t;
        let e;
        let r;
        let o;
        const u = c(null);
      return (
        n.inline ||
          ((e = u),
          (t = n).addCommand("mceFullScreen", function () {
            xn(t, e);
          }),
          (o = u),
          (r = n).ui.registry.addToggleMenuItem("fullscreen", {
            text: "Fullscreen",
            icon: "fullscreen",
            shortcut: "Meta+Shift+F",
            onAction () {
              return r.execCommand("mceFullScreen");
            },
            onSetup: Dn(r, o),
          }),
          r.ui.registry.addToggleButton("fullscreen", {
            tooltip: "Fullscreen",
            icon: "fullscreen",
            onAction () {
              return r.execCommand("mceFullScreen");
            },
            onSetup: Dn(r, o),
          }),
          n.addShortcut("Meta+Shift+F", "", "mceFullScreen")),
        i(u)
      );
    });
  })();
})(window);
