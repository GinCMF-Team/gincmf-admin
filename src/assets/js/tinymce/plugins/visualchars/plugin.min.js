/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.4.1 (2020-07-08)
 */
!(function (r) {
  
  let n;
    let t;
    let e;
    let o;
    let u;
    let i;
    const c = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const a = function (n) {
      return function () {
        return n;
      };
    };
    const s = a(!1);
    const f = a(!0);
    const l = function () {
      return d;
    };
    var d =
      ((n = function (n) {
        return n.isNone();
      }),
      {
        fold (n, t) {
          return n();
        },
        is: s,
        isSome: s,
        isNone: f,
        getOr: (e = function (n) {
          return n;
        }),
        getOrThunk: (t = function (n) {
          return n();
        }),
        getOrDie (n) {
          throw new Error(n || "error: getOrDie called on none.");
        },
        getOrNull: a(null),
        getOrUndefined: a(undefined),
        or: e,
        orThunk: t,
        map: l,
        each () {},
        bind: l,
        exists: s,
        forall: f,
        filter: l,
        equals: n,
        equals_: n,
        toArray () {
          return [];
        },
        toString: a("none()"),
      });
    var m = function (e) {
      const n = a(e);
        const t = function () {
          return o;
        };
        const r = function (n) {
          return n(e);
        };
        var o = {
          fold (n, t) {
            return t(e);
          },
          is (n) {
            return e === n;
          },
          isSome: f,
          isNone: s,
          getOr: n,
          getOrThunk: n,
          getOrDie: n,
          getOrNull: n,
          getOrUndefined: n,
          or: t,
          orThunk: t,
          map (n) {
            return m(n(e));
          },
          each (n) {
            n(e);
          },
          bind: r,
          exists: r,
          forall: r,
          filter (n) {
            return n(e) ? o : d;
          },
          toArray () {
            return [e];
          },
          toString () {
            return `some(${  e  })`;
          },
          equals (n) {
            return n.is(e);
          },
          equals_ (n, t) {
            return n.fold(s, function (n) {
              return t(e, n);
            });
          },
        };
      return o;
    };
    const v = function (n) {
      return n === null || n === undefined ? d : m(n);
    };
    const g = function (t) {
      return function (n) {
        return typeof n === t;
      };
    };
    const h =
      ((o = "string"),
      function (n) {
        return (
          (e = typeof (t = n)),
          (t === null
            ? "null"
            : e == "object" &&
              (Array.prototype.isPrototypeOf(t) ||
                (t.constructor && t.constructor.name === "Array"))
            ? "array"
            : e == "object" &&
              (String.prototype.isPrototypeOf(t) ||
                (t.constructor && t.constructor.name === "String"))
            ? "string"
            : e) === o
        );
        let t; let e;
      });
    const p = g("boolean");
    const y = g("number");
    const w = function (n, t) {
      for (let e = 0, r = n.length; e < r; e++) {
        t(n[e], e);
      }
    };
    const b = Object.keys;
    const N = function (n, t) {
      for (let e = b(n), r = 0, o = e.length; r < o; r++) {
        const u = e[r];
        t(n[u], u);
      }
    };
    const T =
      (typeof r.window !== "undefined" ? r.window : Function("return this;")(),
      function (n) {
        return n.dom().nodeValue;
      });
    const k =
      ((u = 3),
      function (n) {
        return n.dom().nodeType === u;
      });
    const A = function (n, t, e) {
      !(function (n, t, e) {
        if (!(h(e) || p(e) || y(e)))
          throw (
            (r.console.error(
              "Invalid call to Attr.set. Key ",
              t,
              ":: Value ",
              e,
              ":: Element ",
              n
            ),
            new Error("Attribute value was not simple"))
          );
        n.setAttribute(t, `${e  }`);
      })(n.dom(), t, e);
    };
    const O = function (n, t) {
      n.dom().removeAttribute(t);
    };
    const C = function (n, t) {
      let e;
        let r;
        const o = ((e = t), (r = n.dom().getAttribute(e)) === null ? undefined : r);
      return o === undefined || o === "" ? [] : o.split(" ");
    };
    const S = function (n) {
      return n.dom().classList !== undefined;
    };
    const D = function (n, t) {
      return (
        (o = t),
        (u = C((e = n), (r = "class")).concat([o])),
        A(e, r, u.join(" ")),
        !0
      );
      let e; let r; let o; let u;
    };
    const E = function (n, t) {
      return (
        (o = t),
        (u = (function (n, t) {
          for (var e = [], r = 0, o = n.length; r < o; r++) {
            const u = n[r];
            t(u, r) && e.push(u);
          }
          return e;
        })(C((e = n), (r = "class")), function (n) {
          return n !== o;
        })).length >
        0
          ? A(e, r, u.join(" "))
          : O(e, r),
        !1
      );
      let e; let r; let o; let u;
    };
    const L = function (n) {
      (S(n) ? n.dom().classList : C(n, "class")).length === 0 && O(n, "class");
    };
    const x = function (n) {
      if (n === null || n === undefined)
        throw new Error("Node cannot be null or undefined");
      return { dom: a(n) };
    };
    const V = {
      fromHtml (n, t) {
        const e = (t || r.document).createElement("div");
        if (((e.innerHTML = n), !e.hasChildNodes() || e.childNodes.length > 1))
          throw (
            (r.console.error("HTML does not have a single root node", n),
            new Error("HTML must have a single root node"))
          );
        return x(e.childNodes[0]);
      },
      fromTag (n, t) {
        const e = (t || r.document).createElement(n);
        return x(e);
      },
      fromText (n, t) {
        const e = (t || r.document).createTextNode(n);
        return x(e);
      },
      fromDom: x,
      fromPoint (n, t, e) {
        const r = n.dom();
        return v(r.elementFromPoint(t, e)).map(x);
      },
    };
    const B = { "\xa0": "nbsp", "\xad": "shy" };
    const P = function (n, t) {
      let e = "";
      return (
        N(n, function (n, t) {
          e += t;
        }),
        new RegExp(`[${  e  }]`, t ? "g" : "")
      );
    };
    const _ = P(B);
    const j = P(B, !0);
    const M =
      ((i = ""),
      N(B, function (n) {
        i && (i += ","), (i += `span.mce-${  n}`);
      }),
      i);
    const q = "mce-nbsp";
    const H = function (n) {
      return (
        `<span data-mce-bogus="1" class="mce-${  B[n]  }">${  n  }</span>`
      );
    };
    const F = function (n) {
      const t = T(n);
      return k(n) && t !== undefined && _.test(t);
    };
    var I = function (n, t) {
      let e = [];
        const r = (function (n, t) {
          for (var e = n.length, r = new Array(e), o = 0; o < e; o++) {
            const u = n[o];
            r[o] = t(u, o);
          }
          return r;
        })(n.dom().childNodes, V.fromDom);
      return (
        w(r, function (n) {
          t(n) && (e = e.concat([n])), (e = e.concat(I(n, t)));
        }),
        e
      );
    };
    const U = function (n) {
      return (
        n.nodeName.toLowerCase() === "span" &&
        n.classList.contains("mce-nbsp-wrap")
      );
    };
    const K = function (c, n) {
      const t = I(V.fromDom(n), F);
      w(t, function (n) {
        let t;
          let e;
          const r = n.dom().parentNode;
        if (U(r))
          (t = V.fromDom(r)),
            (e = q),
            S(t) ? t.dom().classList.add(e) : D(t, e);
        else {
          for (
            let o = c.dom.encode(T(n)).replace(j, H),
              u = c.dom.create("div", null, o),
              i = void 0;
            (i = u.lastChild);

          )
            c.dom.insertAfter(i, n.dom());
          c.dom.remove(n.dom());
        }
      });
    };
    const R = function (t, n) {
      const e = t.dom.select(M, n);
      w(e, function (n) {
        U(n)
          ? (function (n, t) {
              S(n) ? n.dom().classList.remove(t) : E(n, t);
              L(n);
            })(V.fromDom(n), q)
          : t.dom.remove(n, !0);
      });
    };
    const z = function (n) {
      const t = n.getBody();
        const e = n.selection.getBookmark();
        let r = (function (n, t) {
          for (; n.parentNode; ) {
            if (n.parentNode === t) return n;
            n = n.parentNode;
          }
        })(n.selection.getNode(), t);
      (r = r !== undefined ? r : t),
        R(n, r),
        K(n, r),
        n.selection.moveToBookmark(e);
    };
    const G = function (n, t) {
      let e;
        let r;
        const o = n.getBody();
        const u = n.selection;
      t.set(!t.get()),
        (e = n),
        (r = t.get()),
        e.fire("VisualChars", { state: r });
      const i = u.getBookmark();
      (!0 === t.get() ? K : R)(n, o), u.moveToBookmark(i);
    };
    const J = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const Q = function (e, r) {
      return function (t) {
        t.setActive(r.get());
        const n = function (n) {
          return t.setActive(n.state);
        };
        return (
          e.on("VisualChars", n),
          function () {
            return e.off("VisualChars", n);
          }
        );
      };
    };
  !(function W() {
    c.add("visualchars", function (n) {
      let t;
        let e;
        let r;
        let o;
        let u;
        let i;
        let c;
        let a;
        let s;
        let f;
        let l;
        const d =
          ((t = !1),
          {
            get () {
              return t;
            },
            set (n) {
              t = n;
            },
          });
      return (
        (r = d),
        (e = n).addCommand("mceVisualChars", function () {
          G(e, r);
        }),
        (u = d),
        (o = n).ui.registry.addToggleButton("visualchars", {
          tooltip: "Show invisible characters",
          icon: "visualchars",
          onAction () {
            return o.execCommand("mceVisualChars");
          },
          onSetup: Q(o, u),
        }),
        o.ui.registry.addToggleMenuItem("visualchars", {
          text: "Show invisible characters",
          icon: "visualchars",
          onAction () {
            return o.execCommand("mceVisualChars");
          },
          onSetup: Q(o, u),
        }),
        (i = n),
        (c = d),
        (a = J.debounce(function () {
          z(i);
        }, 300)),
        !1 !== i.getParam("forced_root_block") &&
          i.on("keydown", function (n) {
            !0 === c.get() && (n.keyCode === 13 ? z(i) : a());
          }),
        (f = d),
        (s = n).on("init", function () {
          const n = !s.getParam("visualchars_default_state", !1);
          f.set(n), G(s, f);
        }),
        (l = d),
        {
          isEnabled () {
            return l.get();
          },
        }
      );
    });
  })();
})(window);
