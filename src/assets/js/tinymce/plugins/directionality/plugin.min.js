/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.4.1 (2020-07-08)
 */
!(function (u) {
  
  let n;
    let t;
    let e;
    let o;
    const r = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const i = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const c = function (n, t) {
      let e;
        const o = n.dom;
        const r = n.selection.getSelectedBlocks();
      r.length &&
        ((e = o.getAttrib(r[0], "dir")),
        i.each(r, function (n) {
          o.getParent(n.parentNode, `*[dir="${  t  }"]`, o.getRoot()) ||
            o.setAttrib(n, "dir", e !== t ? t : null);
        }),
        n.nodeChanged());
    };
    const f = function (n) {
      return function () {
        return n;
      };
    };
    const d = f(!1);
    const l = f(!0);
    const m = function () {
      return a;
    };
    var a =
      ((n = function (n) {
        return n.isNone();
      }),
      {
        fold (n, t) {
          return n();
        },
        is: d,
        isSome: d,
        isNone: l,
        getOr: (e = function (n) {
          return n;
        }),
        getOrThunk: (t = function (n) {
          return n();
        }),
        getOrDie (n) {
          throw new Error(n || "error: getOrDie called on none.");
        },
        getOrNull: f(null),
        getOrUndefined: f(undefined),
        or: e,
        orThunk: t,
        map: m,
        each () {},
        bind: m,
        exists: d,
        forall: l,
        filter: m,
        equals: n,
        equals_: n,
        toArray () {
          return [];
        },
        toString: f("none()"),
      });
    var s = function (e) {
      const n = f(e);
        const t = function () {
          return r;
        };
        const o = function (n) {
          return n(e);
        };
        var r = {
          fold (n, t) {
            return t(e);
          },
          is (n) {
            return e === n;
          },
          isSome: l,
          isNone: d,
          getOr: n,
          getOrThunk: n,
          getOrDie: n,
          getOrNull: n,
          getOrUndefined: n,
          or: t,
          orThunk: t,
          map (n) {
            return s(n(e));
          },
          each (n) {
            n(e);
          },
          bind: o,
          exists: o,
          forall: o,
          filter (n) {
            return n(e) ? r : a;
          },
          toArray () {
            return [e];
          },
          toString () {
            return `some(${  e  })`;
          },
          equals (n) {
            return n.is(e);
          },
          equals_ (n, t) {
            return n.fold(d, function (n) {
              return t(e, n);
            });
          },
        };
      return r;
    };
    const g = {
      some: s,
      none: m,
      from (n) {
        return n === null || n === undefined ? a : s(n);
      },
    };
    const h = function (n) {
      if (n === null || n === undefined)
        throw new Error("Node cannot be null or undefined");
      return { dom: f(n) };
    };
    const y = {
      fromHtml (n, t) {
        const e = (t || u.document).createElement("div");
        if (((e.innerHTML = n), !e.hasChildNodes() || e.childNodes.length > 1))
          throw (
            (u.console.error("HTML does not have a single root node", n),
            new Error("HTML must have a single root node"))
          );
        return h(e.childNodes[0]);
      },
      fromTag (n, t) {
        const e = (t || u.document).createElement(n);
        return h(e);
      },
      fromText (n, t) {
        const e = (t || u.document).createTextNode(n);
        return h(e);
      },
      fromDom: h,
      fromPoint (n, t, e) {
        const o = n.dom();
        return g.from(o.elementFromPoint(t, e)).map(h);
      },
    };
    const v =
      ((o = "function"),
      function (n) {
        return typeof n === o;
      });
    const p =
      (typeof u.window !== "undefined" ? u.window : Function("return this;")(),
      function (t) {
        return function (n) {
          return n.dom().nodeType === t;
        };
      });
    const T = p(3);
    const w = p(9);
    const N = p(11);
    const D =
      v(u.Element.prototype.attachShadow) && v(u.Node.prototype.getRootNode)
        ? function (n) {
            return y.fromDom(n.dom().getRootNode());
          }
        : function (n) {
            return w(n) ? n : ((t = n), y.fromDom(t.dom().ownerDocument));
            let t;
          };
    const O = function (n) {
      const t = D(n);
      return N(t) ? g.some(t) : g.none();
    };
    const C = function (n) {
      return y.fromDom(n.dom().host);
    };
    var S = function (n) {
      let t;
        let e;
        const o = T(n) ? n.dom().parentNode : n.dom();
      return (
        o !== undefined &&
        o !== null &&
        o.ownerDocument !== null &&
        O(y.fromDom(o)).fold(
          function () {
            return o.ownerDocument.body.contains(o);
          },
          ((t = S),
          (e = C),
          function (n) {
            return t(e(n));
          })
        )
      );
    };
    const L = function (n, t) {
      return (e = n).style !== undefined && v(e.style.getPropertyValue)
        ? n.style.getPropertyValue(t)
        : "";
      let e;
    };
    const R = function (n) {
      return ((e = "direction"),
        (o = (t = n).dom()),
        (r = u.window.getComputedStyle(o).getPropertyValue(e)) !== "" || S(t)
          ? r
          : L(o, e)) ===
        "rtl"
        ? "rtl"
        : "ltr";
      let t; let e; let o; let r;
    };
    const A = function (t, o) {
      return function (e) {
        const n = function (n) {
          const t = y.fromDom(n.element);
          e.setActive(R(t) === o);
        };
        return (
          t.on("NodeChange", n),
          function () {
            return t.off("NodeChange", n);
          }
        );
      };
    };
  !(function P() {
    r.add("directionality", function (n) {
      let t; let e;
      (t = n).addCommand("mceDirectionLTR", function () {
        c(t, "ltr");
      }),
        t.addCommand("mceDirectionRTL", function () {
          c(t, "rtl");
        }),
        (e = n).ui.registry.addToggleButton("ltr", {
          tooltip: "Left to right",
          icon: "ltr",
          onAction () {
            return e.execCommand("mceDirectionLTR");
          },
          onSetup: A(e, "ltr"),
        }),
        e.ui.registry.addToggleButton("rtl", {
          tooltip: "Right to left",
          icon: "rtl",
          onAction () {
            return e.execCommand("mceDirectionRTL");
          },
          onSetup: A(e, "rtl"),
        });
    });
  })();
})(window);
